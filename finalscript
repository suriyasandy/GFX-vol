import streamlit as st
import pandas as pd
import plotly.express as px
import re

st.set_page_config(layout="wide")
st.title("ğŸ“Š FX Threshold Recalibration & Impact Analysis (Final Corrected)")

# ----------------------------------------------------------
# SECTION 0: (OPTIONAL) SAMPLE DATA FOR INSTANT TESTING
# ----------------------------------------------------------
# You can remove or comment out once you upload your real files.
sample_threshold_csv = """CCY,Group,value
USD,Group 1,0.010
EUR,Group 2,0.020
JPY,Group 2,0.021
INR,Group 3,0.030
"""
sample_trade_csv = """trade_id,currency_pair,deviation_percent,base_curr_group,orig_curr_group,legal_entity,trade_date
1,USD,0.009,1,1,Entity_A,2023-01-15
2,EUR,0.025,2,2,Entity_A,2023-02-20
3,JPY,0.018,2,2,Entity_B,2023-02-28
4,INR,0.028,3,3,Entity_B,2023-03-05
5,USD,0.012,1,2,Entity_A,2023-03-15
6,EUR,0.018,2,3,Entity_B,2023-04-01
"""
st.sidebar.markdown("### (Optional) Copy/Paste these CSV contents to test quickly:")
st.sidebar.text_area("Sample Threshold CSV", sample_threshold_csv, height=150)
st.sidebar.text_area("Sample Trade CSV", sample_trade_csv, height=150)
# ----------------------------------------------------------

st.sidebar.header("ğŸ“ Upload Your Files")
threshold_file = st.sidebar.file_uploader("Upload Threshold CSV (with columns CCY, Group, value)", type="csv")
trade_files   = st.sidebar.file_uploader("Upload One or More Trade CSVs", type="csv", accept_multiple_files=True)

@st.cache_data
def load_csv(file) -> pd.DataFrame:
    try:
        return pd.read_csv(file)
    except Exception:
        st.error("âŒ Unable to parse one of the CSVs. Please check for proper CSV formatting.")
        return pd.DataFrame()

def clean_group_column(df: pd.DataFrame) -> pd.DataFrame:
    """
    Ensures df['Group'] contains only integers. Converts "Group 1" â†’ 1, "1" â†’ 1.
    Drops any rows where Group cannot be parsed.
    """
    if "Group" not in df.columns:
        st.error("Threshold file is missing a 'Group' column.")
        return pd.DataFrame()

    df = df.copy()
    # Extract digits anywhere in the string
    df["Group"] = df["Group"].astype(str).str.extract(r"(\d+)")[0]
    df = df.dropna(subset=["Group"])
    try:
        df["Group"] = df["Group"].astype(int)
    except Exception:
        st.error("âŒ Could not convert all 'Group' values to integers. Check your threshold file.")
        return pd.DataFrame()
    return df

# ----------------------------------------------------------
# SECTION 1: LOAD & VALIDATE THRESHOLD FILE
# ----------------------------------------------------------
if threshold_file is None:
    st.warning("ğŸ“¥ Please upload your Threshold CSV.")
    st.stop()

df_threshold = load_csv(threshold_file)
df_threshold = clean_group_column(df_threshold)
if df_threshold.empty:
    st.error("âŒ Threshold file could not be loaded or cleaned. Exiting.")
    st.stop()

# Verify required columns
missing_thresh_cols = [c for c in ["CCY","Group","value"] if c not in df_threshold.columns]
if missing_thresh_cols:
    st.error(f"âŒ Threshold file is missing column(s): {missing_thresh_cols}")
    st.stop()

# Force correct types
df_threshold["CCY"] = df_threshold["CCY"].astype(str)
df_threshold["value"] = pd.to_numeric(df_threshold["value"], errors="coerce")
df_threshold = df_threshold.dropna(subset=["value"])

st.markdown("### ğŸ§¾ Cleaned Threshold File Preview:")
st.dataframe(df_threshold.head())

# ----------------------------------------------------------
# SECTION 2: LOAD & COMBINE TRADE FILE(S)
# ----------------------------------------------------------
if not trade_files:
    st.warning("ğŸ“¥ Please upload at least one Trade CSV.")
    st.stop()

trade_dfs = []
for tf in trade_files:
    _df = load_csv(tf)
    if not _df.empty:
        trade_dfs.append(_df)
if not trade_dfs:
    st.error("âŒ None of the uploaded trade files could be parsed. Exiting.")
    st.stop()

df_trades = pd.concat(trade_dfs, ignore_index=True)
st.success(f"âœ… Loaded {len(trade_dfs)} trade file(s). Combined row count: {len(df_trades)}")

# ----------------------------------------------------------
# SECTION 3: VALIDATE & CLEAN TRADE DATA
# ----------------------------------------------------------
required_trade_cols = ["trade_id", "currency_pair", "deviation_percent", "base_curr_group", "orig_curr_group", "legal_entity"]
missing_trade_cols = [c for c in required_trade_cols if c not in df_trades.columns]
if missing_trade_cols:
    st.error(f"âŒ Trade file(s) missing column(s): {missing_trade_cols}")
    st.stop()

# Convert types
df_trades["trade_id"]         = pd.to_numeric(df_trades["trade_id"], errors="coerce")
df_trades["deviation_percent"] = pd.to_numeric(df_trades["deviation_percent"], errors="coerce")
df_trades["base_curr_group"]   = pd.to_numeric(df_trades["base_curr_group"], errors="coerce")
df_trades["orig_curr_group"]   = pd.to_numeric(df_trades["orig_curr_group"], errors="coerce")
df_trades["legal_entity"]      = df_trades["legal_entity"].astype(str)

# Drop any rows with missing required fields
df_trades = df_trades.dropna(subset=["trade_id", "currency_pair", "deviation_percent", "base_curr_group", "orig_curr_group", "legal_entity"])
df_trades["trade_id"]         = df_trades["trade_id"].astype(int)
df_trades["base_curr_group"]  = df_trades["base_curr_group"].astype(int)
df_trades["orig_curr_group"]  = df_trades["orig_curr_group"].astype(int)

# If 'trade_date' exists, parse it
has_date = "trade_date" in df_trades.columns
if has_date:
    df_trades["trade_date"] = pd.to_datetime(df_trades["trade_date"], errors="coerce")

# Compute max_group
df_trades["max_group"] = df_trades[["base_curr_group","orig_curr_group"]].max(axis=1)

st.markdown("### ğŸ§¾ Cleaned Trade Data Preview:")
st.dataframe(df_trades.head())

# ----------------------------------------------------------
# SECTION 4: TOGGLE BETWEEN â€œBy Groupâ€ or â€œBy Currencyâ€
# ----------------------------------------------------------
recal_mode = st.sidebar.radio("ğŸ”„ Recalibration Mode", ["By Group", "By Currency"], index=0)
df_result = pd.DataFrame()

if recal_mode == "By Group":
    st.sidebar.header("ğŸ”§ Adjust Thresholds by Group")

    unique_groups = sorted(df_threshold["Group"].unique())
    new_group_list = []
    for g in unique_groups:
        old_val = float(df_threshold[df_threshold["Group"] == g]["value"].mean())
        new_val = st.sidebar.number_input(f"Group {g} Threshold", value=old_val, format="%.5f", key=f"grp_{g}")
        new_group_list.append({"Group": g, "Old Threshold": old_val, "New Threshold": new_val, "Delta": round(new_val - old_val,5)})

    df_group_thresh = pd.DataFrame(new_group_list)
    df_group_thresh["Group Label"] = df_group_thresh["Group"].apply(lambda x: f"Group {x}")

    st.subheader("ğŸ”„ Threshold Change Summary (Group Level)")
    st.dataframe(df_group_thresh[["Group Label","Old Threshold","New Threshold","Delta"]])

    # Build lookup dict: {group â†’ new_threshold}
    lookup = df_group_thresh.set_index("Group")["New Threshold"].to_dict()

    # Filter trades whose max_group exists in lookup
    df_grp = df_trades[df_trades["max_group"].isin(lookup.keys())].copy()
    if df_grp.empty:
        st.error("âŒ None of the tradesâ€™ max_group match the recalibrated groups. Check your groups.")
        st.stop()

    df_grp["threshold_used"] = df_grp["max_group"].map(lookup)
    df_result = df_grp

else:  # â€œBy Currencyâ€
    st.sidebar.header("ğŸ”§ Adjust Thresholds by Currency")

    if "CCY" not in df_threshold.columns:
        st.error("âŒ Cannot run â€œBy Currencyâ€ mode: your threshold file lacks a â€˜CCYâ€™ column.")
        st.stop()

    group_ranges = df_threshold.groupby("Group")["value"].agg(["min","max"]).reset_index()
    currency_list = []
    for ccy in sorted(df_threshold["CCY"].unique()):
        old_val = float(df_threshold[df_threshold["CCY"] == ccy]["value"].iloc[0])
        new_val = st.sidebar.number_input(f"{ccy} Threshold", value=old_val, format="%.5f", key=f"ccy_{ccy}")
        # We do NOT reassign group here; we just override the threshold for that CCY
        currency_list.append({"CCY": ccy, "Old": old_val, "New": new_val})

    df_currency_override = pd.DataFrame(currency_list)
    st.subheader("ğŸ”„ Threshold Change Summary (Currency Level)")
    st.dataframe(df_currency_override)

    # Merge directly on currency_pair â†’ CCY
    df_cur = df_trades.merge(
        df_currency_override.rename(columns={"CCY":"currency_pair"}),
        on="currency_pair", how="left"
    ).copy()
    if "New" not in df_cur.columns:
        st.error("âŒ Currencyâ€level merge failed. Check that each tradeâ€™s `currency_pair` exists in threshold fileâ€™s `CCY`.")
        st.stop()

    df_cur["threshold_used"] = df_cur["New"]
    df_result = df_cur

# ----------------------------------------------------------
# SECTION 5: FLAG â€œis_within_thresholdâ€ AND VALIDATE
# ----------------------------------------------------------
if df_result.empty or "threshold_used" not in df_result.columns:
    st.error("âŒ Threshold assignment failed. Verify your files and toggle settings.")
    st.stop()

df_result["is_within_threshold"] = df_result["deviation_percent"] <= df_result["threshold_used"]

# ----------------------------------------------------------
# SECTION 6: GROUP-LEVEL IMPACT SUMMARY
# ----------------------------------------------------------
st.subheader("ğŸ“Š Group-Level Impact Summary")
group_summary = (
    df_result
    .groupby("max_group", observed=True)
    .agg(
        Total_Trades=('trade_id','count'),
        Breaches=('is_within_threshold', lambda x: (~x).sum()),
        Within_Threshold=('is_within_threshold','sum')
    )
    .reset_index()
)
group_summary["Breach %"] = round((group_summary["Breaches"]/group_summary["Total_Trades"])*100,2)
group_summary["Group Label"] = group_summary["max_group"].apply(lambda x: f"Group {x}")

st.dataframe(group_summary[["Group Label","Total_Trades","Breaches","Within_Threshold","Breach %"]])

fig_bar = px.bar(
    group_summary, x="Group Label", y="Breach %",
    text="Breach %",
    color="Breach %",
    color_continuous_scale="Reds",
    title="ğŸš¦ Breach % by Group"
)
fig_bar.update_traces(texttemplate="%{text}%", textposition="outside")
st.plotly_chart(fig_bar, use_container_width=True)

# ----------------------------------------------------------
# SECTION 7: TIME-BASED (MONTHLY) IMPACT (IF trade_date EXISTS)
# ----------------------------------------------------------
if "trade_date" in df_result.columns and not df_result["trade_date"].isna().all():
    df_tm = df_result.copy()
    df_tm["trade_date"] = pd.to_datetime(df_tm["trade_date"], errors="coerce")
    df_tm = df_tm.dropna(subset=["trade_date"])
    if not df_tm.empty:
        df_tm["Month"] = df_tm["trade_date"].dt.to_period("M").astype(str)
        monthly = (
            df_tm
            .groupby("Month", observed=True)
            .agg(
                Total_Trades=('trade_id','count'),
                Breaches=('is_within_threshold', lambda x: (~x).sum())
            )
            .reset_index()
        )
        monthly["Breach %"] = round((monthly["Breaches"]/monthly["Total_Trades"])*100,2)

        with st.expander("ğŸ“… Impact Over Time (Monthly)"):
            st.dataframe(monthly)
            fig_line = px.line(
                monthly, x="Month", y="Breach %",
                markers=True,
                title="ğŸ“ˆ Monthly Breach % Trend"
            )
            st.plotly_chart(fig_line, use_container_width=True)

# ----------------------------------------------------------
# SECTION 8: SAMPLE â€œCURRENCY PAIR - LEVELâ€ DETAIL (FIRST 5 PAIRS)
# ----------------------------------------------------------
st.subheader("ğŸ“‚ Currency-Pair Level Details (Sample)")

all_pairs = df_result["currency_pair"].dropna().unique()
sample_pairs = all_pairs[:5]  # show first 5 to avoid UI overload
for pair in sample_pairs:
    with st.expander(f"ğŸ” Pair: {pair} (Top 100 rows)"):
        df_pair = df_result[df_result["currency_pair"] == pair]
        st.markdown(
            f"**Total Trades:** {len(df_pair)}     |   "
            f"**Breaches:** {int((~df_pair['is_within_threshold']).sum())}     |   "
            f"**Compliant:** {int(df_pair['is_within_threshold'].sum())}"
        )
        st.dataframe(
            df_pair[["trade_id","legal_entity","deviation_percent","threshold_used","is_within_threshold"]]
            .head(100)
        )

# ----------------------------------------------------------
# SECTION 9: DOWNLOAD FULL RESULTS
# ----------------------------------------------------------
st.download_button(
    "ğŸ“¥ Download Full Recalibrated Results as CSV",
    df_result.to_csv(index=False),
    "fx_threshold_recalibrated_results.csv"
)

import streamlit as st
import pandas as pd
import plotly.express as px
import re
from io import StringIO

st.set_page_config(layout="wide")
st.title("üìä FX Threshold Recalibration & Impact Analysis")

# ----------------------------------------------------------
# SECTION 0: SAMPLE DATA (for quick copy/paste testing)
# ----------------------------------------------------------
#
# You can comment out or remove this entire block once you're uploading real files.
#
sample_threshold_csv = """CCY,Group,value
USD,Group 1,0.010
EUR,Group 2,0.020
JPY,Group 2,0.021
INR,Group 3,0.030
"""
sample_trade_csv = """trade_id,currency_pair,deviation_percent,base_curr_group,orig_curr_group,legal_entity,trade_date
1,USD,0.009,1,1,Entity_A,2023-01-15
2,EUR,0.025,2,2,Entity_A,2023-02-20
3,JPY,0.018,2,2,Entity_B,2023-02-28
4,INR,0.028,3,3,Entity_B,2023-03-05
5,USD,0.012,1,2,Entity_A,2023-03-15
6,EUR,0.018,2,3,Entity_B,2023-04-01
"""
st.sidebar.markdown("### (Optional) Copy/Paste these into 'Upload CSV' dialogs to test:")
st.sidebar.text_area("Sample Threshold CSV", sample_threshold_csv, height=150)
st.sidebar.text_area("Sample Trade CSV", sample_trade_csv, height=200)
# ----------------------------------------------------------

st.sidebar.header("üìÅ Upload Your Files")
threshold_file = st.sidebar.file_uploader("Upload Threshold CSV (with columns CCY, Group, value)", type="csv")
trade_files   = st.sidebar.file_uploader("Upload Trade CSV(s)", type="csv", accept_multiple_files=True)

@st.cache_data
def load_csv(file) -> pd.DataFrame:
    try:
        return pd.read_csv(file)
    except Exception:
        st.error("‚ùå Could not parse one of the uploaded CSVs. Please check delimiter/encoding.")
        return pd.DataFrame()

def clean_group_column(df: pd.DataFrame) -> pd.DataFrame:
    """
    Takes df["Group"], which might be strings like "Group 1", "1", or numbers,
    and converts them into integer 1, 2, 3, etc. Drops rows where Group can't be parsed.
    """
    if "Group" not in df.columns:
        st.error("Threshold file is missing a 'Group' column.")
        return pd.DataFrame()

    # Extract digits anywhere in the string
    df = df.copy()
    df["Group"] = df["Group"].astype(str).str.extract(r"(\d+)")[0]
    df = df.dropna(subset=["Group"])
    df["Group"] = df["Group"].astype(int)
    return df

if threshold_file is None or not trade_files:
    st.warning("üì• Please upload BOTH a threshold CSV and at least one trade CSV.")
    st.stop()

# ----------------------------------------------------------
# SECTION 1: LOAD & CLEAN THRESHOLD FILE
# ----------------------------------------------------------
df_threshold = load_csv(threshold_file)
df_threshold = clean_group_column(df_threshold)

if df_threshold.empty:
    st.error("‚ùå Threshold file could not be loaded or cleaned. Exiting.")
    st.stop()

# Ensure required columns exist
missing_thresh_cols = [c for c in ["CCY", "Group", "value"] if c not in df_threshold.columns]
if missing_thresh_cols:
    st.error(f"‚ùå Threshold file is missing column(s): {missing_thresh_cols}")
    st.stop()

st.markdown("### üßæ Cleaned Threshold File (Top 5 rows)")
st.dataframe(df_threshold.head())

# ----------------------------------------------------------
# SECTION 2: LOAD & CONCATENATE TRADE FILES
# ----------------------------------------------------------
trade_dfs = []
for tf in trade_files:
    _df = load_csv(tf)
    if not _df.empty:
        trade_dfs.append(_df)
if not trade_dfs:
    st.error("‚ùå None of the trade files could be loaded. Exiting.")
    st.stop()

df_trades = pd.concat(trade_dfs, ignore_index=True)
st.success(f"‚úÖ Loaded {len(trade_files)} trade file(s); combined into {len(df_trades)} trades.")

# ----------------------------------------------------------
# SECTION 3: ENSURE TRADE COLUMNS & CLEAN
# ----------------------------------------------------------
required_trade_cols = ["trade_id", "currency_pair", "deviation_percent", "base_curr_group", "orig_curr_group", "legal_entity"]
missing_trade_cols = [c for c in required_trade_cols if c not in df_trades.columns]
if missing_trade_cols:
    st.error(f"‚ùå Trade file(s) missing column(s): {missing_trade_cols}. Exiting.")
    st.stop()

# If there's a trade_date column, convert it to datetime
has_date = "trade_date" in df_trades.columns
if has_date:
    df_trades["trade_date"] = pd.to_datetime(df_trades["trade_date"], errors="coerce")

# Force numeric types where needed
df_trades["deviation_percent"] = pd.to_numeric(df_trades["deviation_percent"], errors="coerce")
df_trades["base_curr_group"]  = pd.to_numeric(df_trades["base_curr_group"], errors="coerce")
df_trades["orig_curr_group"]  = pd.to_numeric(df_trades["orig_curr_group"], errors="coerce")
df_trades["trade_id"]         = pd.to_numeric(df_trades["trade_id"], errors="coerce")

# Drop any trade rows missing key info
df_trades = df_trades.dropna(subset=["trade_id", "currency_pair", "deviation_percent", "base_curr_group", "orig_curr_group", "legal_entity"])
df_trades["base_curr_group"] = df_trades["base_curr_group"].astype(int)
df_trades["orig_curr_group"] = df_trades["orig_curr_group"].astype(int)
df_trades["legal_entity"]    = df_trades["legal_entity"].astype(str)

# Compute max_group = max(base_curr_group, orig_curr_group)
df_trades["max_group"] = df_trades[["base_curr_group", "orig_curr_group"]].max(axis=1)

# Preview
st.markdown("### üßæ Cleaned Trade Data (Top 5 rows)")
st.dataframe(df_trades.head())

# ----------------------------------------------------------
# SECTION 4: TOGGLE BETWEEN "By Group" or "By Currency"
# ----------------------------------------------------------
recal_mode = st.sidebar.radio("üîÑ Recalibration Mode", ["By Group", "By Currency"], index=0)

df_result = pd.DataFrame()  # final result placeholder

if recal_mode == "By Group":
    st.sidebar.header("üîß Adjust Thresholds by Group")

    unique_groups = sorted(df_threshold["Group"].unique())
    new_tuples = []
    for g in unique_groups:
        old_val = float(df_threshold.loc[df_threshold["Group"] == g, "value"].mean())
        new_val = st.sidebar.number_input(f"Group {g} Threshold", value=old_val, format="%.5f", key=f"grp_{g}")
        new_tuples.append({
            "Group": g,
            "Old Threshold": old_val,
            "New Threshold": new_val,
            "Delta": round(new_val - old_val, 5)
        })

    df_group_thresh = pd.DataFrame(new_tuples)
    df_group_thresh["Group Label"] = df_group_thresh["Group"].apply(lambda x: f"Group {x}")

    st.subheader("üîÑ Threshold Change Summary (Group Level)")
    st.dataframe(df_group_thresh[["Group Label", "Old Threshold", "New Threshold", "Delta"]])

    # Build a lookup dict: {group ‚Üí new_value}
    recal_dict = df_group_thresh.set_index("Group")["New Threshold"].to_dict()

    # Filter only trades whose max_group exists in recalibrated groups
    df_res = df_trades[df_trades["max_group"].isin(recal_dict.keys())].copy()
    if df_res.empty:
        st.error("‚ùå No trades fall into the selected Group(s). Check group assignments.")
        st.stop()

    # Assign threshold_used = recal_dict[max_group]
    df_res["threshold_used"] = df_res["max_group"].map(recal_dict)
    df_result = df_res

else:  # recal_mode == "By Currency"
    st.sidebar.header("üîß Adjust Thresholds by Currency")

    # Ensure the threshold file has a CCY column
    if "CCY" not in df_threshold.columns:
        st.error("‚ùå Threshold file must contain a 'CCY' column in 'By Currency' mode.")
        st.stop()

    group_ranges = df_threshold.groupby("Group")["value"].agg(["min", "max"]).reset_index()

    currency_tuples = []
    for ccy in sorted(df_threshold["CCY"].dropna().unique()):
        old_val = float(df_threshold.loc[df_threshold["CCY"] == ccy, "value"].iloc[0])
        new_val = st.sidebar.number_input(f"{ccy} Threshold", value=old_val, format="%.5f", key=f"ccy_{ccy}")
        # Figure out which group-range this new_val falls into
        matched_group = None
        for _, row in group_ranges.iterrows():
            if row["min"] <= new_val <= row["max"]:
                matched_group = int(row["Group"])
                break
        if matched_group is None:
            # Default to original currency group if out of all defined ranges
            matched_group = int(df_threshold.loc[df_threshold["CCY"] == ccy, "Group"].iloc[0])

        currency_tuples.append({
            "CCY": ccy,
            "Old": old_val,
            "New": new_val,
            "Group": matched_group,
            "Delta": round(new_val - old_val, 5)
        })

    df_currency_thresh = pd.DataFrame(currency_tuples)
    df_currency_thresh["Group Label"] = df_currency_thresh["Group"].apply(lambda x: f"Group {x}")

    st.subheader("üîÑ Threshold Change Summary (Currency Level)")
    st.dataframe(df_currency_thresh[["CCY", "Old", "New", "Group Label", "Delta"]])

    # Merge thresholds onto trades by currency_pair ‚Üí CCY
    df_res = df_trades.merge(
        df_currency_thresh.rename(columns={"CCY": "currency_pair"}),
        on="currency_pair",
        how="left"
    ).copy()

    if "New" not in df_res.columns:
        st.error("‚ùå Currency‚Äêlevel merge failed. Check that each trade's currency_pair appears in threshold file under CCY.")
        st.stop()

    df_res["threshold_used"] = df_res["New"]
    df_result = df_res

# ----------------------------------------------------------
# SECTION 5: EVALUATE 'is_within_threshold' & FAILURE CASE
# ----------------------------------------------------------
if df_result.empty or "threshold_used" not in df_result.columns:
    st.error("‚ùå Threshold assignment failed. Please verify your inputs and mappings.")
    st.stop()

df_result["is_within_threshold"] = df_result["deviation_percent"] <= df_result["threshold_used"]

# ----------------------------------------------------------
# SECTION 6: GROUP-LEVEL IMPACT SUMMARY
# ----------------------------------------------------------
st.subheader("üìä Threshold Impact Summary by Group")

group_summary = (
    df_result
    .groupby("max_group", observed=True)
    .agg(
        Total_Trades=('trade_id', 'count'),
        Breaches=('is_within_threshold', lambda x: (~x).sum()),
        Within_Threshold=('is_within_threshold', 'sum'),
    )
    .reset_index()
)
group_summary["Breach %"] = round((group_summary["Breaches"] / group_summary["Total_Trades"]) * 100, 2)
group_summary["Group Label"] = group_summary["max_group"].apply(lambda x: f"Group {x}")

st.dataframe(group_summary[["Group Label", "Total_Trades", "Breaches", "Within_Threshold", "Breach %"]])

fig_kpi = px.bar(
    group_summary,
    x="Group Label", y="Breach %",
    text="Breach %",
    color="Breach %",
    color_continuous_scale="Reds",
    title="üö¶ Breach % by Group"
)
fig_kpi.update_traces(texttemplate="%{text}%", textposition="outside")
st.plotly_chart(fig_kpi, use_container_width=True)

# ----------------------------------------------------------
# SECTION 7: TIME-BASED IMPACT (MONTHLY)
# ----------------------------------------------------------
if "trade_date" in df_result.columns and not df_result["trade_date"].isna().all():
    df_tm = df_result.copy()
    df_tm["trade_date"] = pd.to_datetime(df_tm["trade_date"], errors="coerce")
    df_tm = df_tm.dropna(subset=["trade_date"])
    if not df_tm.empty:
        df_tm["Month"] = df_tm["trade_date"].dt.to_period("M").astype(str)
        monthly = (
            df_tm
            .groupby("Month", observed=True)
            .agg(
                Total_Trades=('trade_id', 'count'),
                Breaches=('is_within_threshold', lambda x: (~x).sum()),
            )
            .reset_index()
        )
        monthly["Breach %"] = round((monthly["Breaches"] / monthly["Total_Trades"]) * 100, 2)

        with st.expander("üìÖ Impact Over Time (Monthly)"):
            st.dataframe(monthly)
            fig_month = px.line(
                monthly, x="Month", y="Breach %",
                markers=True,
                title="üìà Monthly Breach % Trend"
            )
            st.plotly_chart(fig_month, use_container_width=True)

# ----------------------------------------------------------
# SECTION 8: CURRENCY PAIR-LEVEL DETAIL (SHOW FIRST 5 ONLY)
# ----------------------------------------------------------
st.subheader("üìÇ Currency Pair-Level Details (Sample)")

all_pairs = df_result["currency_pair"].dropna().unique()
sample_pairs = all_pairs[:5]  # show only first 5 currency pairs to avoid overload
for pair in sample_pairs:
    with st.expander(f"üîç Pair: {pair} (Top 100 rows)"):
        df_pair = df_result[df_result["currency_pair"] == pair]
        st.markdown(f"**Total Trades:** {len(df_pair)}  |  **Breaches:** {int((~df_pair['is_within_threshold']).sum())}  |  **Compliant:** {int(df_pair['is_within_threshold'].sum())}")
        st.dataframe(df_pair[["trade_id", "legal_entity", "deviation_percent", "threshold_used", "is_within_threshold"]].head(100))

# ----------------------------------------------------------
# SECTION 9: DOWNLOAD FINAL RESULTS
# ----------------------------------------------------------
st.download_button(
    "üì• Download Full Recalibrated Results as CSV",
    df_result.to_csv(index=False),
    "fx_threshold_recalibrated_results.csv"
)
"""

# Write the final file to disk
with open(f"{st.secrets.get('HOME','/mnt/data')}/app_fx_threshold_final.py", "w") as f:
    f.write(streamlit_code)

st.success("‚úÖ App code written to `app_fx_threshold_final.py`. Run it with:  `streamlit run app_fx_threshold_final.py` ")
